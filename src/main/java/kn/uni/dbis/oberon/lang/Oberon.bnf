{
  parserClass="kn.uni.dbis.oberon.lang.parser.OberonParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  elementTypeHolderClass="kn.uni.dbis.oberon.lang.psi.OberonTypes"

  elementTypeClass="kn.uni.dbis.oberon.lang.psi.OberonElementType"
  tokenTypeClass="kn.uni.dbis.oberon.lang.psi.OberonTokenType"

  psiClassPrefix="Oberon"
  psiImplClassSuffix="Impl"
  psiPackage="kn.uni.dbis.oberon.lang.psi"
  psiImplPackage="kn.uni.dbis.oberon.lang.psi.impl"
  psiImplUtilClass="kn.uni.dbis.oberon.lang.psi.impl.OberonPsiImplUtil"

  tokens = [
    COMMENT="COMMENT"

    // Basics
    COLON = ":"
    COMMA = ","
    LBRACE = "{"
    LBRACK = "["
    LPAREN = "("
    PERIOD = "."
    PIPE = "|"
    RANGE = ".."
    RBRACE = "}"
    RBRACK = "]"
    RPAREN = ")"
    SEMICOLON = ";"
    VARARGS = "..."

    // Keywords
    KW_AND = "AND"
    KW_ARRAY = "ARRAY"
    KW_BEGIN = "BEGIN"
    KW_BOOLEAN = "BOOLEAN"
    KW_BY = "BY"
    KW_CASE = "CASE"
    KW_CONST = "CONST"
    KW_DO = "DO"
    KW_ELSE = "ELSE"
    KW_ELSIF = "ELSIF"
    KW_END = "END"
    KW_EXIT = "EXIT"
    KW_EXTERN = "EXTERN"
    KW_FALSE = "FALSE"
    KW_FOR = "FOR"
    KW_FUNCTION = "FUNCTION"
    KW_IF = "IF"
    KW_IMPORT = "IMPORT"
    KW_INTEGER = "INTEGER"
    KW_LONGINT = "LONGINT"
    KW_LONGREAL = "LONGREAL"
    KW_LOOP = "LOOP"
    KW_MODULE = "MODULE"
    KW_NEW = "NEW"
    KW_NIL = "NIL"
    KW_OF = "OF"
    KW_POINTER = "POINTER"
    KW_PROCEDURE = "PROCEDURE"
    KW_REAL = "REAL"
    KW_RECORD = "RECORD"
    KW_REPEAT = "REPEAT"
    KW_RETURN = "RETURN"
    KW_STRING = "STRING"
    KW_THEN = "THEN"
    KW_TO = "TO"
    KW_TRUE = "TRUE"
    KW_TYPE = "TYPE"
    KW_UNTIL = "UNTIL"
    KW_VAR = "VAR"
    KW_WITH = "WITH"
    KW_WHILE = "WHILE"

    // Operators
    OP_AND = "&"
    OP_BECOMES = ":="
    OP_DEREF = "^"
    OP_DIV = "DIV"
    OP_DIVIDE = "/"
    OP_EQ = "="
    OP_GEQ = ">="
    OP_GT = ">"
    OP_IN = "IN"
    OP_IS = "IS"
    OP_LEQ = "<="
    OP_LT = "<"
    OP_MINUS = "-"
    OP_MOD = "MOD"
    OP_NEQ = "#"
    OP_NOT = "~"
    OP_OR = "OR"
    OP_PLUS = "+"
    OP_TIMES = "*"
  ]
}

module ::= KW_MODULE ident SEMICOLON [ import_list ] declaration_sequence [ KW_BEGIN <<semicolon_list statement>> ] KW_END ident PERIOD
import_list ::= KW_IMPORT <<comma_list import>> SEMICOLON
import ::= ident [ OP_BECOMES ident ]

private meta comma_list ::= <<p>> (COMMA <<p>>)*
private meta semicolon_list ::= <<p>> (SEMICOLON <<p>>)*

ident ::= IDENTIFIER | builtin_type
qualident ::= [ ident PERIOD ] ident
identdef ::= ident [ OP_TIMES ]

number ::= INTEGER_LITERAL | REAL_LITERAL
string ::= STRING_LITERAL

builtin_type ::= KW_INTEGER | KW_LONGINT | KW_REAL | KW_LONGREAL | KW_BOOLEAN | KW_STRING

const_declaration ::= identdef OP_EQ expression

type_declaration ::= identdef OP_EQ type
type ::= qualident | array_type | record_type | pointer_type | procedure_type
array_type ::= KW_ARRAY expression ( COMMAN expression )* KW_OF type
record_type ::= KW_RECORD [ LPAREN qualident RPAREN ] [ <<semicolon_list field_list>> ] KW_END
field_list ::= <<comma_list identdef>> COLON type
pointer_type ::= KW_POINTER KW_TO type
procedure_type ::= KW_PROCEDURE [ formal_parameters ]

variable_declaration ::= <<comma_list identdef>> COLON type

expression ::= simple_expression [ relation simple_expression ]
relation ::= OP_EQ | OP_NEQ | OP_LT | OP_LEQ | OP_GT | OP_GEQ | OP_IN | OP_IS
simple_expression ::= [ OP_PLUS | OP_MINUS ] term ( and_operator term )*
and_operator ::= OP_PLUS | OP_MINUS | OP_OR
term ::= factor ( mult_operator factor )*
mult_operator ::= OP_TIMES | OP_DIVIDE | OP_DIV | OP_MOD | OP_AND
factor ::= number | string | KW_NIL | KW_TRUE | KW_FALSE | set | designator [ actual_parameters ] |
           LPAREN expression RPAREN | OP_NOT factor
designator ::= qualident ( selector )*
selector ::= PERIOD ident | LBRACK <<comma_list expression>> RBRACK | OP_DEREF | LPAREN qualident RPAREN
set ::= LBRACE [ <<comma_list element>> ] RBRACE
element ::= expression [ RANGE expression ]
actual_parameters ::= LPAREN [ <<comma_list expression>> ] RPAREN

statement ::= [ assignment | procedure_call | if_statement | case_statement |
                while_statement | repeat_statement | for_statement | loop_statement |
                /* with_statement | */ KW_EXIT ]
assignment ::= designator OP_BECOMES expression
procedure_call ::= designator [ actual_parameters ]
if_statement ::= KW_IF expression KW_THEN <<semicolon_list statement>>
                 ( KW_ELSIF expression KW_THEN <<semicolon_list statement>> )*
                 [ KW_ELSE <<semicolon_list statement>> ] KW_END
case_statement ::= KW_CASE expression KW_OF case ( PIPE case ) KW_END
case ::= [ <<comma_list label_range>> COLON <<semicolon_list statement>> ]
label_range ::= label [ RANGE label ]
label ::= integer | string | qualident
while_statement ::= KW_WHILE expression KW_DO <<semicolon_list statement>>
                    ( KW_ELSIF expression KW_DO <<semicolon_list statement>> )*
                    KW_END
repeat_statement ::= KW_REPEAT <<semicolon_list statement>> KW_UNTIL expression
for_statement ::= KW_FOR ident OP_BECOMES expression KW_TO expression [ KW_BY expression ] KW_DO <<semicolon_list statement>> KW_END
loop_statement ::= LW_LOOP <<semicolon_list statement>> KW_END

procedure_declaration ::= procedure_heading SEMICOLON ( procedure_body ident | KW_EXTERN )
procedure_heading ::= KW_PROCEDURE identdef [ formal_parameters ]
procedure_body ::= declaration_sequence [ KW_BEGIN <<semicolon_list statement>> ] [ KW_RETURN expression ] KW_END
declaration_sequence ::= [ KW_CONST ( const_declaration SEMICOLON )* ]
                         [ KW_TYPE ( type_declaration SEMICOLON )* ]
                         [ KW_VAR ( variable_declaration SEMICOLON )* ]
                         ( procedure_declaration SEMICOLON )*
formal_parameters ::= LPAREN [ <<semicolon_list fp_section>> ] RPAREN [ COLON qualident ]
fp_section ::= ( [ KW_VAR ] <<comma_list ident>> COLON [ KW_ARRAY KW_OF ] qualident | VARARGS )
